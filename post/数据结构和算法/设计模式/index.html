<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>设计模式 - ZsmHub - Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ZsmHub" /><meta name="description" content="设计模式简介 设计模式一套被反复使用，多数人知晓的代码设计经验的总结，实现可重用代码，使代码更容易被理解，保证代码可靠性。 总体来说，设计模式分" /><meta name="keywords" content="Hugo, even, zsmhub, blog, php, golang" />






<meta name="generator" content="Hugo 0.82.0 with theme even" />


<link rel="canonical" href="https://zsmhub.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.eb0308f0e54ff86bb150b0f7f2912dd5f4eb4f67b1ee508094605ecd5b7dd679.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="设计模式" />
<meta property="og:description" content="设计模式简介 设计模式一套被反复使用，多数人知晓的代码设计经验的总结，实现可重用代码，使代码更容易被理解，保证代码可靠性。 总体来说，设计模式分" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zsmhub.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-02-15T21:05:40&#43;08:00" />
<meta property="article:modified_time" content="2020-02-15T21:05:40&#43;08:00" />

<meta itemprop="name" content="设计模式">
<meta itemprop="description" content="设计模式简介 设计模式一套被反复使用，多数人知晓的代码设计经验的总结，实现可重用代码，使代码更容易被理解，保证代码可靠性。 总体来说，设计模式分"><meta itemprop="datePublished" content="2020-02-15T21:05:40&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-15T21:05:40&#43;08:00" />
<meta itemprop="wordCount" content="2866">
<meta itemprop="keywords" content="设计模式," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设计模式"/>
<meta name="twitter:description" content="设计模式简介 设计模式一套被反复使用，多数人知晓的代码设计经验的总结，实现可重用代码，使代码更容易被理解，保证代码可靠性。 总体来说，设计模式分"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">ZsmHub Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/navigation">
        <li class="mobile-menu-item">导航</li>
      </a><a href="/about">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">ZsmHub Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/navigation">导航</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">设计模式</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-15 </span>
        <div class="post-category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"> 数据结构和算法 </a>
            </div>
          <span class="more-meta"> 约 2866 字 </span>
          <span class="more-meta"> 预计阅读 6 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计模式简介">设计模式简介</a></li>
    <li><a href="#常见的设计模式">常见的设计模式</a></li>
    <li><a href="#工作案例">工作案例</a></li>
    <li><a href="#参考文章">参考文章</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计模式简介">设计模式简介</h2>
<p>设计模式一套被反复使用，多数人知晓的代码设计经验的总结，实现可重用代码，使代码更容易被理解，保证代码可靠性。</p>
<blockquote>
<p>总体来说，设计模式分为三大类：</p>
</blockquote>
<ul>
<li>创建型模式（五种）：单例模式、工厂模式、抽象工厂模式、创建者模式、原型模式</li>
<li>结构型模式（七种）：适配器模式、代理模式、装饰器模式、外观模式、桥接模式、组合模式、享元模式</li>
<li>行为型模式（十一种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<blockquote>
<p>算法执行的步骤是稳定不变的，但是具体的某些算法可能存在变化的场景。</p>
</blockquote>
<p>怎么理解，举个例子：比如说你煮个面，必然需要先烧水，水烧开之后再放面进去，以上的流程我们称之为煮面过程。可知：这个煮面过程的步骤是稳定不变的，但是在不同的环境烧水的方式可能不尽相同，也许有的人用天然气烧水、有的人用电磁炉烧水、有的人用柴火烧水，等等。我们可以得到以下结论：</p>
<ul>
<li>煮面过程的步骤是稳定不变的</li>
<li>煮面过程的烧水方式是可变的</li>
</ul>
<h2 id="常见的设计模式">常见的设计模式</h2>
<ol>
<li>
<p>单例模式（最简单的一种设计模式）</p>
<p>使用懒惰模式的单例模式，使用双重检查加锁保证线程安全『对象仅实例化一次』</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CustomValidator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">once</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
    <span class="nx">validate</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">lazyInit</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">lazyInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">validate</span> <span class="p">=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>工厂模式 vs 抽象工厂模式</p>
<blockquote>
<p>定义</p>
</blockquote>
<ul>
<li>工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类</li>
<li>抽象工厂模式 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类</li>
</ul>
<blockquote>
<p>区别</p>
</blockquote>
<p>工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。『示例：在每一个层次，种菜工人所关心的对象也不一样，在简单工厂模式下，工人要想到种植萝卜还是白菜，在工厂模式下，工人想到是种植根菜还是茎菜，而在抽象工厂模式下，则关心种植基因菜还是非基因菜。』</p>
<p><img src="/images/2020/QQ20201130-174630.png" alt="工厂模式和抽象工厂模式的区别"></p>
<p><img src="/images/2020/QQ20201130-175923.png" alt="示例1"></p>
<p><img src="/images/2020/QQ20201130-175958.png" alt="示例2">)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//Operator 是被封装的实际类接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Operator</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">SetA</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="nf">Result</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OperatorB</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">SetB</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="nf">Result</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">//OperatorFactory 采用了工厂模式
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OperatorFactory</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Create</span><span class="p">()</span> <span class="nx">Operator</span> <span class="c1">// 种菜
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//OperatorFactory 采用了抽象工厂模式
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OperatorFactory2</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">CreateA</span><span class="p">()</span> <span class="nx">Operator</span>  <span class="c1">// 种根菜
</span><span class="c1"></span>    <span class="nf">CreateB</span><span class="p">()</span> <span class="nx">OperatorB</span> <span class="c1">// 种芹菜
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>创建者模式</p>
<p>应用场景：一些基本组件不会变，而其组合经常变化的时候。『有相同的接口方法，但各自拥有特殊的接口方法』</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Builder</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Part1</span><span class="p">()</span>
    <span class="nf">Part2</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Director</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">builder</span> <span class="nx">Builder</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Director</span><span class="p">)</span> <span class="nf">Construct</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">builder</span><span class="p">.</span><span class="nf">Part1</span><span class="p">()</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">builder</span><span class="p">.</span><span class="nf">Part2</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewDirector</span><span class="p">(</span><span class="nx">builder</span> <span class="nx">Builder</span><span class="p">)</span> <span class="o">*</span><span class="nx">Director</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Director</span><span class="p">{</span>
        <span class="nx">builder</span><span class="p">:</span> <span class="nx">builder</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Builder1</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">Part1</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="s">&#34;1&#34;</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">Part2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="s">&#34;2&#34;</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">GetResult</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="c1">// Builder1 特殊方法
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">result</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Builder2</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">Part1</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">Part2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">GetResult2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="c1">// Builder2 特殊方法
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 测试用例
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestBuilder1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">builder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Builder1</span><span class="p">{}</span>
    <span class="nx">director</span> <span class="o">:=</span> <span class="nf">NewDirector</span><span class="p">(</span><span class="nx">builder</span><span class="p">)</span>
    <span class="nx">director</span><span class="p">.</span><span class="nf">Construct</span><span class="p">()</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nx">builder</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="s">&#34;12&#34;</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Builder1 fail expect 12 acture %s&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">TestBuilder2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">builder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Builder2</span><span class="p">{}</span>
    <span class="nx">director</span> <span class="o">:=</span> <span class="nf">NewDirector</span><span class="p">(</span><span class="nx">builder</span><span class="p">)</span>
    <span class="nx">director</span><span class="p">.</span><span class="nf">Construct</span><span class="p">()</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nx">builder</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Builder2 fail expect 3 acture %d&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>适配器模式 vs 装饰器模式</p>
<blockquote>
<p>适配器模式：抛弃旧接口逻辑，访问旧接口时直接调转到请求新接口</p>
</blockquote>
<p>意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
主要解决：主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p>优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
<p>缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<p>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<blockquote>
<p>装饰器模式：继承旧接口逻辑，新接口获取旧接口返回值后，增加新的补充逻辑</p>
</blockquote>
<p>装饰模式使用对象组合的方式动态改变或增加对象行为。</p>
</li>
<li>
<p>代理模式</p>
<p>代理模式用于延迟处理操作或者在进行实际操作前后进行其它处理。</p>
<p>实际案例：如控制器层调用业务层的方法前，可以做一些参数验证(如中间件)等，调用业务层的方法后，再做一些数据封装等，最终输出结果。整理流程来看，控制器层的用法就是代理模式。</p>
</li>
<li>
<p>模板模式</p>
<p>抽象类里定义好算法的执行步骤和具体算法，以及可能发生变化的算法定义为抽象方法。不同的子类继承该抽象类，并实现父类的抽象方法。</p>
<blockquote>
<p>模板模式的优势：</p>
</blockquote>
<ul>
<li>不变的算法被继承复用：不变的部分高度封装、复用。</li>
<li>变化的算法子类继承并具体实现：变化的部分子类只需要具体实现抽象的部分即可，方便扩展，且可无限扩展。</li>
</ul>
</li>
<li>
<p>职责链模式 vs 组合模式</p>
<blockquote>
<p>职责链模式</p>
</blockquote>
<p>首先把一系列业务按职责划分成不同的对象，接着把这一系列对象构成一个链，然后在这一系列对象中传递请求对象，直到被处理为止。</p>
<p>具体优势：</p>
<ul>
<li>直观：一眼可观的业务调用过程</li>
<li>无限扩展：可无限扩展的业务逻辑</li>
<li>高度封装：复杂业务代码依然高度封装</li>
<li>极易被修改：复杂业务代码下修改代码只需要专注对应的业务类(结构体)文件即可，以及极易被调整的业务执行顺序</li>
</ul>
<blockquote>
<p>「职责链模式」 与「组合模式」的区别：</p>
</blockquote>
<ul>
<li>职责链模式: 链表</li>
<li>组合模式：树</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 职责链模式-商城购物下单业务示例
</span><span class="c1">// Context Context
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// Handler 处理
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// 自身的业务
</span><span class="c1"></span>    <span class="nf">Do</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
    <span class="c1">// 设置下一个对象
</span><span class="c1"></span>    <span class="nf">SetNext</span><span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="nx">Handler</span>
    <span class="c1">// 递归执行
</span><span class="c1"></span>    <span class="nf">Run</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="c1">// Next 抽象出来的 可被合成复用的结构体
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Next</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 下一个对象
</span><span class="c1"></span>    <span class="nx">nextHandler</span> <span class="nx">Handler</span>
<span class="p">}</span>

<span class="c1">// SetNext 实现好的 可被复用的SetNext方法
</span><span class="c1">// 返回值是下一个对象 方便写成链式代码优雅
</span><span class="c1">// 例如 nullHandler.SetNext(argumentsHandler).SetNext(signHandler).SetNext(frequentHandler)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Next</span><span class="p">)</span> <span class="nf">SetNext</span><span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="nx">Handler</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">nextHandler</span> <span class="p">=</span> <span class="nx">h</span>
    <span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>

<span class="c1">// Run 执行
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Next</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 由于go无继承的概念 这里无法执行当前handler的Do
</span><span class="c1"></span>    <span class="c1">// n.Do(c)
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">nextHandler</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 合成复用下的变种
</span><span class="c1"></span>        <span class="c1">// 执行下一个handler的Do
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">nextHandler</span><span class="p">).</span><span class="nf">Do</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="c1">// 执行下一个handler的Run
</span><span class="c1"></span>        <span class="k">return</span> <span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">nextHandler</span><span class="p">).</span><span class="nf">Run</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// ArgumentsHandler 校验参数的handler
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ArgumentsHandler</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 合成复用Next
</span><span class="c1"></span>    <span class="nx">Next</span>
<span class="p">}</span>

<span class="c1">// Do 校验参数的逻辑
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ArgumentsHandler</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">runFuncName</span><span class="p">(),</span> <span class="s">&#34;校验参数成功...&#34;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// AddressInfoHandler 地址信息handler
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressInfoHandler</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 合成复用Next
</span><span class="c1"></span>    <span class="nx">Next</span>
<span class="p">}</span>

<span class="c1">// Do 校验参数的逻辑
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">AddressInfoHandler</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">runFuncName</span><span class="p">(),</span> <span class="s">&#34;获取地址信息...&#34;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">runFuncName</span><span class="p">(),</span> <span class="s">&#34;地址信息校验...&#34;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">handler</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Next</span><span class="p">{}</span>

    <span class="c1">// 链式调用
</span><span class="c1"></span>    <span class="nx">handler</span><span class="p">.</span><span class="nf">SetNext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ArgumentsHandler</span><span class="p">{}).</span>
        <span class="nf">SetNext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">AddressInfoHandler</span><span class="p">{})</span>
        <span class="c1">//无限扩展代码...
</span><span class="c1"></span>
    <span class="c1">// 开始执行业务
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">handler</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Context</span><span class="p">{});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Fail | Error:&#34;</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Success&#34;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>策略模式 vs 状态模式</p>
<ul>
<li>策略模式：依靠客户决策（如支付方式）</li>
<li>状态模式：依靠内部状态决策（如后端发送短信商的选择）</li>
</ul>
</li>
</ol>
<h2 id="工作案例">工作案例</h2>
<ol>
<li>
<p>Master-Worker模式</p>
<p>其是常用的并行设计模式。核心思想是，系统由两个角色组成，Master和Worker，Master负责接收和分配任务，Worker负责处理子任务。任务处理过程中，Master还负责监督任务进展和Worker的健康状态；Master将接收Client提交的任务，并将任务的进展汇总反馈给Client</p>
<p><img src="/images/2020/QQ20200505-212528%402x.png" alt="图片"></p>
</li>
<li>
<p>典型的客户端 - 服务端模式</p>
</li>
</ol>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="http://wen.topgoer.com/docs/golang-design-pattern/golang-design-pattern-1cbgha2ltg796">Go语言设计模式</a></li>
<li><a href="http://tigerb.cn/go-patterns/#/">Go设计模式实战</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1523363">设计模式中工厂方法与抽象工厂之间的区别联系</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a href="https://zsmhub.github.io/" class="theme-link">ZsmHub</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-02-15
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/sql%E9%9D%A2%E8%AF%95%E9%A2%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">SQL 面试题</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/">
            <span class="next-text nav-default">面试汇总</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2020-02-15 21:05:40 \u002b0800 CST',
        title: '设计模式',
        clientID: 'fe63c88fe7fc18e38512',
        clientSecret: 'e44ced40487d261a6006f9af23a2f788bf1e0a85',
        repo: 'zsmhub.github.io',
        owner: 'zsmhub',
        admin: ['zsmhub'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zhangshimiande@email.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/zsmhub" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy;
    2019 -
    2025
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ZsmHub</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.cddea96674a99fd8cea50d36fb19d9c91f497feea4af5ce4596afd2dbaab9202.js"></script>








</body>
</html>
